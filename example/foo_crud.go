// Package main contains CRUD methods that are generated by `cruder`
// Code generated by "cruder pg Foo ./example/example.go"; DO NOT EDIT
package main

import (
	"database/sql"
	"errors"
	"fmt"
	"strings"
)

type cruderQueryRower interface {
	QueryRow(string, ...interface{}) *sql.Row
}

type cruderQueryer interface {
	Query(string, ...interface{}) (*sql.Rows, error)
}

type cruderSQLFilter interface {
	Where() (string, []interface{})
}

type cruderSQLSorter interface {
	OrderBy() string
}

type cruderExecer interface {
	Exec(string, ...interface{}) (sql.Result, error)
}

// CreateFoo inserts an entry into DB
func CreateFoo(db cruderQueryRower, x Foo) (*Foo, error) {
	var y Foo
	err := db.QueryRow(
		`INSERT INTO Foo (name) VALUES ($1)
		RETURNING id, name`,
		x.Name,
	).Scan(&y.ID, &y.Name)

	return &y, err
}

// GetFoo returns a single entry from DB based on primary key
func GetFoo(db cruderQueryRower, id interface{}) (*Foo, error) {
	var y Foo
	err := db.QueryRow(
		`SELECT id, name FROM Foo WHERE id = $1 AND deleted_at IS NULL`,
		id,
	).Scan(&y.ID, &y.Name)

	return &y, err
}

// ListFoo returns a list of entries from DB based on passed in limit, offset, filters and sorting
func ListFoo(db cruderQueryer, limit, offset uint64, filter cruderSQLFilter, sorter cruderSQLSorter) ([]Foo, error) {
	var args []interface{}
	sqlParts := []string{`SELECT id, name FROM Foo`}

	sqlParts = append(sqlParts, "WHERE deleted_at IS NULL")
	if filter != nil {
		if filters, filterArgs := filter.Where(); filters != "" {
			sqlParts = append(sqlParts, " AND "+filters)
			args = append(args, filterArgs...)
		}
	}

	if sorter != nil {
		if orderBy := sorter.OrderBy(); orderBy != "" {
			sqlParts = append(sqlParts, "ORDER BY "+orderBy)
		}
	}

	if limit > 0 {
		sqlParts = append(sqlParts, fmt.Sprintf("LIMIT %d", limit))
	}
	if offset > 0 {
		sqlParts = append(sqlParts, fmt.Sprintf("OFFSET %d", offset))
	}
	rows, err := db.Query(
		strings.Join(sqlParts, " "),
		args...,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	r := []Foo{}
	for rows.Next() {
		var e Foo
		if err := rows.Scan(id, name); err != nil {
			return nil, err
		}
		r = append(r, e)
	}

	return r, err
}

// UpdateFoo updates an entry into DB
func UpdateFoo(db cruderQueryRower, x Foo) (*Foo, error) {
	var y Foo
	err := db.QueryRow(
		`UPDATE Foo SET name = $1 WHERE id = $1 AND deleted_at IS NULL
		RETURNING id, name`,
		x.Name, x.ID,
	).Scan(&y.ID, &y.Name)

	return &y, err
}

// DeleteFoo deletes an entry from DB
func DeleteFoo(db cruderExecer, id interface{}) error {
	result, err := db.Exec(
		`UPDATE Foo SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL`,
		id,
	)
	if err != nil {
		return err
	}

	if r, err := result.RowsAffected(); err != nil || r == 0 {
		if err != nil {
			return err
		}
		return errors.New("sql: no rows affected")
	}

	return nil
}
