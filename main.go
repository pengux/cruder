package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/pengux/cruder/generator"
)

const (
	funcCreate = "create"
	funcGet    = "get"
	funcList   = "list"
	funcUpdate = "update"
	funcDelete = "delete"
)

var (
	funcs           = flag.String("funcs", "", "comma separated list of CRUD functions to generate, e.g. 'create,get,list,update,delete'")
	output          = flag.String("output", "", "output file name; default srcdir/<struct>_crud.go")
	pkgName         = flag.String("package", "", "package name for the generated code, default to the same package from input")
	table           = flag.String("table", "", "table name in the database, default to <struct>")
	skipFuncSuffix  = flag.Bool("skipsuffix", false, "Skip adding the struct name as suffix to the generated functions")
	readFields      = flag.String("readfields", "", "Fields in the struct that should be used for read operations (get,list). Default to all fields except the one used for softdelete")
	writeFields     = flag.String("writefields", "", "Fields in the struct that should be used for write operations (create,update). Default to all fields")
	primaryField    = flag.String("primaryfield", "", "the field to use as primary key. Default to 'ID' if it exists in the <struct>")
	softDeleteField = flag.String("softdeletefield", "", "the field to use for softdelete (should be of type nullable datetime field). Default to 'DeletedAt' if it exists in the <struct>")
)

// Usage prints the usage of this command with the flags and arguments
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tcruder [flags] [struct] [directory]\n")
	fmt.Fprintf(os.Stderr, "\tcruder [flags] [struct] [files...]\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("cruder: ")
	flag.Usage = Usage
	flag.Parse()

	args := flag.Args()
	if len(args) < 2 {
		flag.Usage()
		os.Exit(2)
	}

	structModel := args[0]

	// If value for flag 'funcs' is not provided, then default to generate all functions
	var funcsToGenerate []string
	if len(*funcs) == 0 {
		funcsToGenerate = []string{funcCreate, funcGet, funcList, funcUpdate, funcDelete}
	} else {
		funcsToGenerate = strings.Split(*funcs, ",")
	}

	// The source should be a directory or list of go files from a single package
	args = args[1:]
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	pkg, dir, err := parsePkg(args)
	if err != nil {
		log.Fatalf("parsing package from provided sources: %s", err)
	}

	gen, err := generator.New(pkg, structModel)
	if err != nil {
		log.Fatalf("could not initialize a new generator: %s", err)
	}

	if len(*pkgName) > 0 {
		gen.PkgName = *pkgName
	}

	if len(*table) > 0 {
		gen.TableName = *table
	}

	gen.SkipSuffix = *skipFuncSuffix

	if len(*readFields) > 0 {
		gen.SetReadFields(strings.Split(*readFields, ","))
	}

	if len(*writeFields) > 0 {
		gen.SetWriteFields(strings.Split(*writeFields, ","))
	}

	if len(*primaryField) > 0 {
		gen.SetPrimaryField(*primaryField)
	}

	if len(*softDeleteField) > 0 {
		gen.SetSoftDeleteField(*softDeleteField)
	}

	for _, funcToGenerate := range funcsToGenerate {
		switch funcToGenerate {
		case funcCreate:
			gen.GenerateCreate()
		case funcGet:
			gen.GenerateGet()
		case funcList:
			gen.GenerateList()
		case funcUpdate:
			gen.GenerateUpdate()
		case funcDelete:
			gen.GenerateDelete()
		}
	}

	// Format the output
	out, err := gen.Format()
	if err != nil {
		log.Print(gen.String())
		log.Print(err)
		log.Fatalf("could not format the generated code, try to compile the code to debug")
	}

	out = append([]byte(fmt.Sprintf("// Package %s contains CRUD methods that are generated by `cruder`\n// Code generated by \"cruder %s\"; DO NOT EDIT\n", pkg.Name(), strings.Join(os.Args[1:], " "))), out...)

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_crud.go", structModel)
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	err = ioutil.WriteFile(outputName, out, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

// prefixDirectory joins the directoy with each filename
func prefixDirectory(directory string, fileNames []string) []string {
	if directory == "." {
		return fileNames
	}
	ret := make([]string, len(fileNames))
	for i, fileName := range fileNames {
		ret[i] = filepath.Join(directory, fileName)
	}
	return ret
}

// parsePkg parses the directory or files for Go code and
// do type-checks on it. It will return the types.Package and
// directory location if successful
func parsePkg(sources []string) (*types.Package, string, error) {
	var (
		dir       string
		fileNames []string
	)
	if len(sources) == 1 && isDirectory(sources[0]) {
		dir = sources[0]
		pkg, err := build.Default.ImportDir(dir, 0)
		if err != nil {
			return nil, dir, fmt.Errorf("cannot process directory %s: %s", dir, err)
		}
		fileNames = append(fileNames, pkg.GoFiles...)
		fileNames = append(fileNames, pkg.CgoFiles...)
		fileNames = append(fileNames, pkg.SFiles...)
		fileNames = prefixDirectory(dir, fileNames)
	} else {
		dir = filepath.Dir(sources[0])
		fileNames = sources
	}

	var (
		astFiles []*ast.File
		pkgName  string
	)
	fset := token.NewFileSet()
	for _, fileName := range fileNames {
		if !strings.HasSuffix(fileName, ".go") {
			continue
		}
		parsedFile, err := parser.ParseFile(fset, fileName, nil, 0)
		if err != nil {
			return nil, dir, fmt.Errorf("parsing package: %s: %s", fileName, err)
		}
		astFiles = append(astFiles, parsedFile)
	}
	if len(astFiles) == 0 {
		return nil, dir, fmt.Errorf("%s: no buildable Go files", dir)
	}

	pkgName = astFiles[0].Name.Name
	conf := types.Config{Importer: importer.Default()}
	pkg, err := conf.Check(pkgName, fset, astFiles, nil)
	if err != nil {
		return nil, dir, fmt.Errorf("type-checking package %s: %s", pkgName, err)
	}

	return pkg, dir, nil
}
