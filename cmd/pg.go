package cmd

import (
	"fmt"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/pengux/cruder/generator"
	"github.com/pengux/cruder/generator/pg"
	"github.com/spf13/cobra"
)

var (
	pgOutput string
	pgTable  string
)

// pgCmd represents the pg command
var pgCmd = &cobra.Command{
	Use:   "pg [flags] <struct> <directory/files...>",
	Short: "Generates CRUD methods for Postgresql, uses the lib/pg package",
	Long:  ``,
	Args:  cobra.MinimumNArgs(2),
	Run: func(cmd *cobra.Command, args []string) {
		structModel := args[0]

		pkg, dir, err := parsePkg(args)
		if err != nil {
			log.Fatalf("parsing package from provided sources: %s", err)
		}

		// Check that struct exists in package
		o := pkg.Scope().Lookup(structModel)
		if o == nil {
			log.Fatalf("the struct %s doesn't seem to exists in package %s", structModel, pkg.Name())
		}
		// Check that it really is of type struct
		t, ok := o.Type().Underlying().(*types.Struct)
		if !ok {
			log.Fatalf("the type %s is not a struct", structModel)
		}

		gen, err := pg.New(pkg, t, structModel)
		if err != nil {
			log.Fatalf("could not initialize a new generator: %s", err)
		}

		if len(pkgName) > 0 {
			gen.PkgName = pkgName
		}

		if len(pgTable) > 0 {
			gen.TableName = pgTable
		}

		gen.SkipSuffix = skipFuncSuffix

		if len(readFields) > 0 {
			gen.SetReadFields(readFields)
		}

		if len(writeFields) > 0 {
			gen.SetWriteFields(writeFields)
		}

		if len(primaryField) > 0 {
			gen.SetPrimaryField(primaryField)
		}

		if len(softDeleteField) > 0 {
			gen.SetSoftDeleteField(softDeleteField)
		}

		for _, funcToGenerate := range funcs {
			switch funcToGenerate {
			case string(generator.Create):
				gen.GenerateCreate()
			case string(generator.Get):
				gen.GenerateGet()
			case string(generator.List):
				gen.GenerateList()
			case string(generator.Update):
				gen.GenerateUpdate()
			case string(generator.Delete):
				gen.GenerateDelete()
			default:
				log.Fatalf("unknown function %s", funcToGenerate)
			}
		}

		// Format the output
		out, err := gen.Format()
		if err != nil {
			log.Print(gen.String())
			log.Print(err)
			log.Fatalf("could not format the generated code, try to compile the code to debug")
		}

		out = append([]byte(fmt.Sprintf("// Package %s contains CRUD methods that are generated by `cruder`\n// Code generated by \"cruder %s\"; DO NOT EDIT\n", pkg.Name(), strings.Join(os.Args[1:], " "))), out...)

		// Write to file.
		if pgOutput == "" {
			baseName := fmt.Sprintf("%s_crud.go", structModel)
			pgOutput = filepath.Join(dir, strings.ToLower(baseName))
		}
		err = ioutil.WriteFile(pgOutput, out, 0644)
		if err != nil {
			log.Fatalf("writing output: %s", err)
		}
	},
}

func init() {
	pgCmd.Flags().StringVarP(&pgOutput, "output", "o", "", "output file name; default srcdir/<struct>_pg_crud.go")
	pgCmd.Flags().StringVar(&pgTable, "table", "", "table name in the database, default to <struct>")

	RootCmd.AddCommand(pgCmd)
}
